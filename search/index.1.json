[{"authors":[],"categories":[{"title":"苍穹外卖笔记","url":"/categories/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E7%AC%94%E8%AE%B0/"}],"content":" Spirng Cache 分类 RedisCache EhCache ConcurrentMapCache 导入依赖 1\u0026lt;dependency\u0026gt; 2 \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; 3 \u0026lt;artifactId\u0026gt;spring-boot-starter-cache\u0026lt;/artifactId\u0026gt; 4\u0026lt;/dependency\u0026gt; 四个注解 @EnableCaching 凯琪缓存注解功能，通常加在启动类application.java上\n1@Slf4j 2@SpringBootApplication 3@EnableCaching 4public class CacheDemoApplication { 5 public static void main(String[] args) { 6 SpringApplication.run(CacheDemoApplication.class,args); 7 log.info(\u0026#34;项目启动成功...\u0026#34;); 8 } 9} @CachePut(cacheNames,key)\n将参数存入reids中，键名为\u0026quot;cacheNames::key\u0026quot; ,\u0026quot;:\u0026ldquo;冒号表示树形结构，相当于java.lang的\u0026rdquo;.”,key用的是EL表达式. 常用于修改。\n1@Insert(\u0026#34;insert into user(name,age) values (#{name},#{age})\u0026#34;) 2 //返回主键 3 @Options(useGeneratedKeys = true,keyProperty = \u0026#34;id\u0026#34;) 4 @CachePut(cacheNames = \u0026#34;userCache\u0026#34;, key = \u0026#34;#user.id\u0026#34;)//userCache 5 void insert(User user); Cacheable\n在方法执行前先查询有无数据，若有，则直接返回缓存数据；若无，则调用方法并将方法返回值存入缓存。常用于查询。\n1 @Cacheable(cacheNames = \u0026#34;userCache\u0026#34; ,key=\u0026#34;#id\u0026#34;) 2public User getById(Long id){ 3 User user = userMapper.getById(id); 4 return user; 5} @CacheEvict\n将一条或多条数据删除,一般用在增/删/改方法中,allEntries为删除满足\u0026quot;cacheNames\u0026quot;前缀的所有记录。\n1\t@DeleteMapping(\u0026#34;/delAll\u0026#34;) 2@CacheEvict(cacheNames = \u0026#34;userCache\u0026#34;,allEntries = true) 3public void deleteAll(){ 4 userMapper.deleteAll(); 5} 注意：Cacheable是在调用方法之前，Spring的代理对象会在数据库中查询数据，若存在，则不调用方法直接返回；若不存在则调用方法。和CachePut不同，CachePut是无论查询到，都会调用方法。\n","date":"2025年8月14日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/notes/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E7%AC%94%E8%AE%B0/springcache.zh-cn/","series":[],"smallImg":"","tags":[{"title":"苍穹外卖","url":"/tags/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/"},{"title":"Spring","url":"/tags/spring/"}],"timestamp":1755139975,"title":"SpringCache.zh Cn"},{"authors":[],"categories":[{"title":"Java后端开发","url":"/categories/java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"content":" Springboot-公共字段填充(Java反射+动态代理+AOP面向切面编程+自定义注解) 我猜你是学黑马的苍穹外卖学到这里了，对不？想了解公共字段填充相关知识？是的，我也是。于是我花了一天时间，查阅相关文档，自己总结了一下。（刚开始写博客，希望大佬多给出建议） 其实这块主要涉及下面四个知识：\n反射 动态代理 AOP 自定义注解 前面三个是层层递进的关系，AOP是基于动态代理实现的，动态代理又用到了反射。 参考文章： https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html https://www.cnblogs.com/gonjan-blog/p/6685611.html https://blog.csdn.net/qq_21187515/article/details/109643130 苍穹外卖公共字段自动注入实现 1.自定义注解，被注解的方法作为链接点 1@Target(ElementType.METHOD) 2@Retention(RetentionPolicy.RUNTIME) 3public @interface AutoFill { 4 OperationType value(); 5 } 2.定义切面类（AOP） 通过定义切面类来指定前后处理逻辑和连接点。\n1@Aspect 2@Component 3@Slf4j 4public class AutoFillAspect { 5 @Pointcut(\u0026#34;execution(* com.sky.mapper.*.*(..))\u0026amp;\u0026amp;@annotation(com.sky.annotation.AutoFill)\u0026#34;) 6 public void autoFillPointcut() { 7 // This method is empty because it serves as a pointcut for the aspect. 8 // The actual logic will be implemented in the advice methods. 9 } 10 @Before(\u0026#34;autoFillPointcut()\u0026#34;) 11 public void beforeAutoFill(JoinPoint joinPoint) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { 12 // 在执行被 @AutoFill 注解的方法之前执行的逻辑 13 // 这里可以添加自动填充的逻辑，比如设置创建时间、更新时间等 14 Long suerId= BaseContext.getCurrentId(); 15 MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); 16 AutoFill autoFillAnnotation = methodSignature.getMethod().getAnnotation(AutoFill.class); 17 OperationType operationType = autoFillAnnotation.value(); 18 Object[] args = joinPoint.getArgs(); 19 if (args != null \u0026amp;\u0026amp; args.length \u0026gt; 0) { 20 return; 21 } 22 LocalDateTime now = LocalDateTime.now(); 23 Long currentId = BaseContext.getCurrentId(); // 获取当前用户ID 24 Object entity = args[0]; // 假设第一个参数是需要填充的实体对象 25 if (operationType == OperationType.INSERT) { 26 // 设置创建时间、创建人等 27 Method setCreateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class); 28 Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class); 29 Method setCreateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class); 30 Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class); 31 setCreateTime.invoke(entity, now); 32 setUpdateTime.invoke(entity, now); 33 setCreateUser.invoke(entity, currentId); 34 setUpdateUser.invoke(entity, currentId); 35 }else if(operationType == OperationType.UPDATE) { 36 // 设置更新时间、更新人等 37 Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class); 38 Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class); 39 setUpdateTime.invoke(entity, now); 40 setUpdateUser.invoke(entity, currentId); 41 } else { 42 log.warn(\u0026#34;Unsupported operation type: {}\u0026#34;, operationType); 43 } 44 } 45} 3.在需要自动注入的方法上加上注解 1 @AutoFill(OperationType.UPDATE) 2 void update(Employee employee); 3 //添加员工 4 @AutoFill(OperationType.INSERT) 5 @Insert(\u0026#34;insert into employee(name, username, password, phone, sex, id_number, create_time, update_time, create_user, update_user)VALUES \u0026#34; + 6 \u0026#34;(#{name}, #{username}, #{password}, #{phone}, #{sex}, #{idNumber}, #{createTime}, #{updateTime}, #{createUser}, #{updateUser})\u0026#34;) 7 void save(Employee employee); 这样，就会在执行修改和增加操作时自动注入创建/修改的用户/时间了\n一、反射 一句话理解：反射是 Java 在运行期“检查并操作类型”的能力。它允许在不知道具体类的情况下，通过字符串名称加载类、构造对象、读取/写入字段、调用方法，甚至读取注解信息。\n先理解一个最小示例 下面用一个最小的示例说明“普通调用 vs 反射调用”的区别与意义。\n首先是一个很简单的 POJO：\n1public class Apple { 2 private int price; 3 4 public int getPrice() { return price; } 5 public void setPrice(int price) { this.price = price; } 6} 上面只是定义了数据结构和 getter/setter，没任何“魔法”。\n接着，分两段演示：先普通方式，再反射方式。\n普通方式（编译期就确定了类型和方法调用） 1Apple apple = new Apple(); 2apple.setPrice(5); 3System.out.println(\u0026#34;Apple Price: \u0026#34; + apple.getPrice()); 这段代码直观、性能最佳，但“灵活性”有限。\n反射方式（运行期再决定要操作哪个类、哪个方法） 1Class\u0026lt;?\u0026gt; clz = Class.forName(\u0026#34;com.chenshuyi.api.Apple\u0026#34;); 2Constructor\u0026lt;?\u0026gt; ctor = clz.getConstructor(); 3Object appleObj = ctor.newInstance(); 4 5Method setPrice = clz.getMethod(\u0026#34;setPrice\u0026#34;, int.class); 6setPrice.invoke(appleObj, 14); 7 8Method getPrice = clz.getMethod(\u0026#34;getPrice\u0026#34;); 9System.out.println(\u0026#34;Apple Price: \u0026#34; + getPrice.invoke(appleObj)); 反射的“动态性”让我们可以在运行期按名称查找类与方法，并进行调用——这正是很多“框架能力”（如自动注入、对象转换、ORM 映射）得以实现的基础。\n两种调用方式的取舍 维度 普通调用 反射调用 调用时机 编译期确定 运行期决定 性能 高 较低（方法查找与校验开销） 安全 编译器检查完善 可能突破访问限制，需要谨慎（利用反射访问private成员） 灵活性 一般 很高（按字符串、配置驱动） 典型场景 业务代码 框架、动态代理、IDE工具 建议：在业务代码中优先普通调用；在“通用能力/框架层”使用反射换取灵活性。\n常用反射操作（聚焦公共字段填充会用到的） 获取 Class 对象： 1Class\u0026lt;?\u0026gt; c1 = Person.class; // 已知类型 2Class\u0026lt;?\u0026gt; c2 = obj.getClass(); // 已有实例 3Class\u0026lt;?\u0026gt; c3 = Class.forName(\u0026#34;x.y.Person\u0026#34;); // 运行期按类名加载 构造与实例化： 1Object target = c3.getDeclaredConstructor().newInstance(); 读写字段（含私有字段）： 1Field f = c3.getDeclaredField(\u0026#34;createTime\u0026#34;); 2f.setAccessible(true); 3f.set(target, LocalDateTime.now()); 调用方法： 1Method m = c3.getMethod(\u0026#34;setUpdateUser\u0026#34;, Long.class); 2m.invoke(target, 1001L); 获取类信息（调试/治理时常用） 1String name = c3.getName(); // 全限定名 2Class\u0026lt;?\u0026gt; sup = c3.getSuperclass(); // 父类 3Class\u0026lt;?\u0026gt;[] ifs = c3.getInterfaces();// 接口 以上就是“自动填充 createTime/updateTime/updateUser”等公共字段时最常用的反射操作。\n二、动态代理 动态代理的“动态”，正是建立在反射之上。它允许我们在不修改原有类的前提下，统一地在方法前后织入逻辑（日志、鉴权、自动填充等）。\n先对比一下静态代理（为理解而简化） 共同接口： 1public interface HouseSeller { 2 void showHouse(); 3 void negotiatePrice(); 4 void signContract(); 5} 被代理对象（房主）： 1public class RealOwner implements HouseSeller { 2 private final String name; 3 public RealOwner(String name) { this.name = name; } 4 public void showHouse() { System.out.println(name + \u0026#34; 开门带看\u0026#34;); } 5 public void negotiatePrice() { System.out.println(name + \u0026#34; 底价 500 万\u0026#34;); } 6 public void signContract() { System.out.println(name + \u0026#34; 签合同\u0026#34;); } 7} 静态代理（中介固定写死在代码里）： 1public class PropertyAgent implements HouseSeller { 2 private final HouseSeller seller; 3 public PropertyAgent(HouseSeller seller) { this.seller = seller; } 4 public void showHouse() { System.out.println(\u0026#34;中介做清洁\u0026#34;); seller.showHouse(); } 5 public void negotiatePrice() { System.out.println(\u0026#34;中介筛选买家\u0026#34;); seller.negotiatePrice(); } 6 public void signContract() { System.out.println(\u0026#34;中介准备合同\u0026#34;); seller.signContract(); } 7} 静态代理的问题是：每加一个新方法都要在代理类里重复一遍，维护成本高。\n动态代理（运行期生成代理类） 定义接口（与被代理对象一致） 1interface HouseSeller { 2 void sellHouse(); 3 void setPrice(float price); 4} 真实对象（房主） 1class RealOwner implements HouseSeller { 2 private float price; 3 public void sellHouse() { System.out.println(\u0026#34;以 \u0026#34; + price + \u0026#34; 万成交\u0026#34;); } 4 public void setPrice(float price) { this.price = price; } 5} 代理的核心：InvocationHandler,并实现invoke方法 1class AgentHandler implements InvocationHandler { 2 private final HouseSeller owner; 3 public AgentHandler(HouseSeller owner) { this.owner = owner; } 4 5 @Override 6 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { 7 System.out.println(\u0026#34;[中介] 统一前置逻辑\u0026#34;); 8 if (\u0026#34;setPrice\u0026#34;.equals(method.getName())) { 9 float original = (float) args[0]; 10 args[0] = original * 1.1f; // 统一加价 10% 11 } 12 Object rst = method.invoke(owner, args); 13 System.out.println(\u0026#34;[中介] 统一后置逻辑\u0026#34;); 14 return rst; 15 } 16} 运行期创建代理并使用 1HouseSeller owner = new RealOwner(); 2HouseSeller agent = (HouseSeller) Proxy.newProxyInstance( 3 owner.getClass().getClassLoader(), 4 owner.getClass().getInterfaces(), 5 new AgentHandler(owner) 6); 7agent.setPrice(500); 8agent.sellHouse(); 动态性的底层原理（JDK 动态代理） 运行期由 Proxy 生成一个实现了目标接口的代理类（典型命名 com.sun.proxy.$Proxy0）。 该代理类内部持有一个 InvocationHandler 引用。 代理类为每个接口方法生成同名方法，方法体统一转发到 handler.invoke(\u0026hellip;)。 需要注意的是：\nJDK 动态代理只代理接口。它在运行期生成一个实现了相同接口的代理类，包含“同名同签名的接口方法”，但这些方法只是转发器，并不会复制真实对象的方法体。 每次调用都会转到 InvocationHandler.invoke(proxy, method, args)。你可以在这里改参、加前后置逻辑，最后决定是否调用 method.invoke(真实对象, 新参数)。 通过“一个 Handler 处理所有方法”，我们可以把横切逻辑集中在一起管理，这就是 AOP 的雏形。\n三、AOP（面向切面编程） AOP 的核心目标：在不改变业务方法代码的前提下，把“横切关注点”（日志、鉴权、事务、公共字段填充）抽取成切面进行统一管理。\n核心术语快速图解 切面（Aspect）：承载横切逻辑的类 切入点（Pointcut）：挑选“哪些方法需要被增强”的条件，为切面类方法的参数\u0026quot;JoinPoint\u0026quot; 通知（Advice）：增强代码本体（前置/后置/异常/环绕） 连接点（JoinPoint）：程序执行到的可被织入的点（在 Spring AOP 中通常就是方法执行） 表格版速查：\n术语 含义 示例/备注 切面 Aspect 横切关注点的载体 一个类上用 @Aspect 标注 切入点 Pointcut 选中需要增强的方法集合的条件 execution(\u0026hellip;) 或 @annotation(\u0026hellip;) 通知 Advice 在切入点处执行的增强代码 @Before/@After/@Around 等 连接点 JoinPoint 实际被拦截到的“点” 在 Spring AOP 中一般是方法执行 切入点表达式两种常用写法（附参数说明） execution 表达式：按“方法签名”匹配 表达式模板：\n1execution( 2 访问修饰符（可省略） 返回值 包名（不建议但可省略）.类名.方法名(参数) throws 异常（可省略） 3) 各部分参数说明：\n部分 必填 说明 示例 访问修饰符 否 public/protected/\u0026hellip;，常省略 public 返回值 是 可用通配符 * 表示任意返回值 * 或 void/String 包名 否 完整包名或.. 通配任意层级 com.sky.mapper.. 类名 是 具体类名或 * 通配 *Mapper 方法名 是 具体方法或 * 通配 save* / * 参数 是 () 无参；(..) 任意；(Type,..) 指定参数 (..)/(Long,*) 异常 否 throws 后可指定异常类型 throws Exception 常见示例：\n1// 任意包下以 Mapper 结尾类的任意方法 2execution(* *..*Mapper.*(..)) 3// 仅匹配 com.sky.mapper 包下所有方法 4execution(* com.sky.mapper.*.*(..)) 5// 精确到方法与参数 6execution(public void com.sky.mapper.UserMapper.save(com.sky.User)) @annotation 表达式：按“方法上标注的注解”匹配 表达式模板：\n1@annotation(注解全名或已导入的简单名) 说明与示例：\n1// 匹配所有被 @AutoFill 标注的方法 2@annotation(com.sky.annotation.AutoFill) 3 4// 与 execution 组合进一步缩小范围 5execution(* com.sky.mapper.*.*(..)) \u0026amp;\u0026amp; @annotation(com.sky.annotation.AutoFill) 对公共字段填充而言，建议“execution 限定范围 + @annotation 声明意图”组合，既安全又直观。\n通知类型一览（表格） 注解 触发时机 是否可拿到返回值/异常 典型用途 @Before 目标方法执行前 无返回值；无异常对象 参数校验、上下文准备、公共字段预填 @After 目标方法执行后（无论是否异常） 无返回值；可知已结束 资源清理、审计日志收尾 @AfterReturning 目标方法正常返回后 可拿到返回值 结果增强、缓存写入 @AfterThrowing 目标方法抛异常时 可拿到异常对象 统一异常日志、告警 @Around 环绕整个调用 可控制执行、获取返回值/异常 事务、性能统计、权限、限流 一个与公共字段填充相关的切面轮廓 切点挑选“Mapper 包下、且标注了 @AutoFill 的方法”：\n1@Aspect 2@Component 3@Slf4j 4public class AutoFillAspect { 5 @Pointcut(\u0026#34;execution(* com.sky.mapper.*.*(..)) \u0026amp;\u0026amp; @annotation(com.sky.annotation.AutoFill)\u0026#34;) 6 public void autoFillPointcut() {} 7} 在执行前织入“自动填充”逻辑（仅展示结构）：\n1@Before(\u0026#34;autoFillPointcut()\u0026#34;) 2public void beforeAutoFill(JoinPoint jp) { 3 // 1) 取出方法参数（如 DTO/Entity） 4 // 2) 通过反射填充 createTime/updateTime/updateUser 等字段 5 // 3) 日志与异常处理 6 log.info(\u0026#34;auto-fill before method: {}\u0026#34;, jp.getSignature()); 7} 四、自定义注解 公共字段填充通常配合“自定义注解”来声明意图：\n1@Target(ElementType.METHOD) 2@Retention(RetentionPolicy.RUNTIME) 3public @interface AutoFill { 4 OperationType value() default INSERT; 5} 这个注解的含义是：标记的方法需要自动填充； value 可指示“操作类型”（如 INSERT/UPDATE），切面可据此决定填充哪些字段。 创建注解要点回顾 访问修饰符：必须是 public 关键字：@interface 元素定义：以“无参方法”形式声明参数，可通过 default 指定默认值 元注解（给注解“加注解”） @Target：注解的使用范围（比如只能标在方法上） @Retention：注解的生命周期（源码/类文件/运行期） @Inherited：注解是否可被子类继承 @Documented：是否生成到 Javadoc @Target 常用取值：\n可选值 适用目标 TYPE 类、接口、枚举 FIELD 字段 METHOD 方法 PARAMETER 方法参数 CONSTRUCTOR 构造器 LOCAL_VARIABLE 局部变量 ANNOTATION_TYPE 注解类型 PACKAGE 包 TYPE_PARAMETER 类型参数（Java 8） TYPE_USE 类型使用（Java 8） @Retention 常用取值：\n生命周期 描述 SOURCE 只存在于源码，编译即丢弃 CLASS 编译进 class，但运行期不可见（默认） RUNTIME 运行期可见（切面/反射最常用） 小结 反射提供“动态读写/调用”的能力，是公共字段自动填充的底层基础； 动态代理把“统一前后置逻辑”抽离出来，避免在每个方法里重复粘贴； AOP 以注解+切点的形式把“横切关注点”模块化管理； 自定义注解则是“声明意图”的方式，让切面只处理该处理的点。 把以上四者串起来，你就能在 SpringBoot 中优雅地实现“创建/更新人、时间”等公共字段的自动填充，既减少重复代码，又提升一致性与可维护性。\nOK,快去敲代码吧！\n","date":"2025年8月4日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/blog/2025/08/springboot-%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3-java%E5%8F%8D%E5%B0%84-aop%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","series":[],"smallImg":"","tags":[{"title":"自定义注解","url":"/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"title":"AOP","url":"/tags/aop/"},{"title":"反射","url":"/tags/%E5%8F%8D%E5%B0%84/"},{"title":"“动态代理”\"spring\"","url":"/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86spring/"},{"title":"Springboot","url":"/tags/springboot/"},{"title":"Java","url":"/tags/java/"}],"timestamp":1754308678,"title":"Springboot-公共字段填充(自定义注解+Java反射+AOP面向切面编程+动态代理)"},{"authors":[],"categories":[{"title":"Java后端开发","url":"/categories/java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"content":" Spring事务详解（基于苍穹外卖项目学习） 最近在学习苍穹外卖项目时，接触到了 Spring 中的事务（@Transactional 注解）。为加深理解，我查阅了一些高质量文章并进行总结，本文将以知识笔记的形式，系统性地讲解 Spring 中的事务机制，便于自己日后查阅与回顾。\n参考文章：\nhttps://javaguide.cn/system-design/framework/spring/spring-transaction.html https://zhuanlan.zhihu.com/p/433276682 一、什么是事务？ 事务（Transaction）是指一组操作的集合，这些操作要么全部成功执行，要么全部不执行，是数据库操作中的基本单位。\n二、事务的ACID特性 事务必须具备以下四个特性（ACID）：\n特性 含义 说明 原子性 (Atomicity) 不可分割 事务作为最小的执行单位，要么全部执行，要么全部回滚 一致性 (Consistency) 数据保持一致 事务执行前后，数据库始终处于一致状态，例如转账时账户总金额不变 隔离性 (Isolation) 并发时互不影响 多个事务并发执行时，各自互不干扰 持久性 (Durability) 一旦提交永久生效 提交后的数据更改是永久性的，即使系统崩溃也不会丢失 补充理解： AID是实现手段，C是一致性目标，只有保障了原子性、隔离性、持久性，一致性才能得以实现。\n三、Spring事务管理机制 Spring 提供了对事务管理的高度抽象和封装，核心接口如下：\nPlatformTransactionManager：事务管理器，定义了事务的基本操作接口。 TransactionDefinition：事务的定义信息，包括隔离级别、传播行为、是否只读、超时时间等。 TransactionStatus：事务的运行状态，包含事务是否新建、是否回滚、是否完成等信息。 1. PlatformTransactionManager Spring 提供了多个事务管理器的实现，常见如下：\n平台 实现类 JDBC DataSourceTransactionManager Hibernate HibernateTransactionManager JPA JpaTransactionManager 使用方式示例：\n1TransactionStatus status = txManager.getTransaction(definition); 2txManager.commit(status); 2. TransactionDefinition（事务属性） 传播行为（Propagation） 隔离级别（Isolation） 超时时间（timeout） 是否只读（readOnly） 异常回滚策略 3. TransactionStatus（事务状态） 1public interface TransactionStatus { 2 boolean isNewTransaction(); // 是否为新事务 3 boolean hasSavepoint(); // 是否有保存点 4 void setRollbackOnly(); // 设置为回滚状态 5 boolean isRollbackOnly(); // 是否处于回滚状态 6 boolean isCompleted(); // 是否已完成 7} 四、事务属性详解 1. 事务传播行为（Propagation） 类型 含义 行为描述 REQUIRED 默认传播行为 如果当前没有事务，则新建事务；如果存在事务，则加入当前事务 REQUIRES_NEW 总是新建事务 如果当前存在事务，则挂起当前事务，创建一个新的事务 NESTED 嵌套事务 如果当前存在事务，则在嵌套事务中执行（有保存点），否则表现为 REQUIRED SUPPORTS 支持事务 如果当前有事务，则加入事务；如果没有事务，则以非事务方式执行 NOT_SUPPORTED 不支持事务 总是以非事务方式执行；如果当前存在事务，则挂起当前事务 NEVER 不允许事务 总是以非事务方式执行；如果当前存在事务，则抛出异常 MANDATORY 必须存在事务 如果当前存在事务，则加入事务；如果没有事务，则抛出异常 2. 事务隔离级别（Isolation） 隔离级别 行为描述 问题类型 性能 READ UNCOMMITTED 允许读取尚未提交的数据 可能出现脏读、不可重复读、幻读 最好 READ COMMITTED 只能读取已提交的数据 可防止脏读，仍可能出现不可重复读、幻读 较好（Oracle 默认） REPEATABLE READ 同一事务中多次读取结果一致，其他事务无法修改已读取数据 可防止脏读、不可重复读，可能有幻读 一般（MySQL 默认） SERIALIZABLE 完全串行化执行事务，防止一切并发问题 可防止所有问题，但性能最差 最差 虚读/幻读：指某事务在两次查询中，其他事务插入了新数据，导致查询结果数量不同。\n3. 事务超时设置 事务超过指定时间未完成，会自动回滚。默认值为 -1，单位是秒。\n1@Transactional(timeout = 10) // 最长执行时间10秒 4. 只读事务 适用于只读操作，数据库可能进行优化，提升查询性能。\n1@Transactional(readOnly = true) 五、@Transactional 注解详解 Spring推荐使用 @Transactional 注解来声明式地管理事务。\n作用范围：类上或方法上（推荐方法上） 不支持接口上使用 仅支持 public 方法上使用 常用属性 属性 说明 默认值 propagation 传播行为 REQUIRED isolation 隔离级别 默认数据库隔离级别 timeout 超时时间 -1（无限） readOnly 是否只读 false rollbackFor 回滚异常类型 RuntimeException 六、事务失效的几种常见情况 情况 说明 修饰方法非 public Spring AOP 基于代理，仅对 public 方法有效 内部方法调用 类内部方法调用不会经过代理，事务不生效 未被 Spring 管理 如未使用 @Component 等注解注册 Bean，事务不生效 数据库不支持事务 如 MyISAM 引擎不支持事务 配置错误 如未正确配置事务管理器或注解 七、使用事务的最佳实践总结 避免在接口上使用 @Transactional 注解； 避免类内部调用事务方法，必要时通过注入方式调用； 指定 rollbackFor，保证异常正确触发回滚； 尽量控制事务范围，不要在事务中处理不必要的逻辑； 使用只读事务优化查询方法； 明确设置事务传播行为，避免传播嵌套问题； 八、Spring Boot 中使用事务示例 下面是一个使用 Spring Boot + MyBatis 的简单事务示例，展示了 @Transactional 的基本使用：\n1@Service 2public class AccountService { 3 4 @Autowired 5 private AccountMapper accountMapper; 6 7 @Transactional(rollbackFor = Exception.class) 8 public void transfer(String fromUser, String toUser, Integer amount) { 9 // 减去转出用户的钱 10 accountMapper.decrease(fromUser, amount); 11 12 // 模拟异常：如除以0会触发事务回滚 13 int error = 1 / 0; 14 15 // 增加接收用户的钱 16 accountMapper.increase(toUser, amount); 17 } 18} 注意：\n被注解方法必须为 public 抛出的异常必须匹配 rollbackFor 如果发生异常，所有数据库操作都会回滚 如果你也在学习 Spring 项目开发，建议结合实际代码、调试日志、数据库回滚等实际效果，多动手实验，才能真正掌握事务机制的运作细节。\n","date":"2025年8月4日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/blog/2025/08/spring%E4%BA%8B%E5%8A%A1/","series":[],"smallImg":"","tags":[{"title":"事务","url":"/tags/%E4%BA%8B%E5%8A%A1/"},{"title":"Spring","url":"/tags/spring/"},{"title":"Springboot","url":"/tags/springboot/"},{"title":"Java","url":"/tags/java/"}],"timestamp":1754308678,"title":"Spring事务"},{"authors":[],"categories":[{"title":"Java后端开发","url":"/categories/java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"content":"这两天在学习苍穹外卖，发现之前学的PageHelper用法忘了，所以阅读了官方文档和相关技术博客，自己再做一个复习。\n1.引入依赖 如果用的是maven，导入以下依赖：\n1\u0026lt;dependency\u0026gt; 2 \u0026lt;groupId\u0026gt;com.github.pagehelper\u0026lt;/groupId\u0026gt; 3 \u0026lt;artifactId\u0026gt;pagehelper-spring-boot-starter\u0026lt;/artifactId\u0026gt; 4\u0026lt;/dependency\u0026gt; 2.相关配置 application配置 完整配置参考 https://github.com/abel533/MyBatis-Spring-Boot/blob/master/src/main/resources/application-old.yml\n以下是和Mybatis相关配置\n1mybatis: 2 type-aliases-package: tk.mybatis.springboot.model 3 mapper-locations: classpath:mapper/*.xml 4 5mapper: 6 mappers: 7 - tk.mybatis.springboot.util.MyMapper 8 not-empty: false 9 identity: MYSQL 10 11pagehelper: 12 helperDialect: mysql 13 reasonable: true 14 supportMethodsArguments: true 15 params: count=countSql 3.在代码中使用 下面演示以下苍穹外卖员工分页查询（根据name模糊查询）相关代码:\nController层 1//controller层 2 @GetMapping(\u0026#34;/page\u0026#34;) 3 @ApiOperation(\u0026#34;分页查询员工\u0026#34;)//swagger接口标签 4 public Result\u0026lt;PageResult\u0026gt; PageQuery(EmployeePageQueryDTO employeePageQueryDTO){ 5 log.info(\u0026#34;分页查询,{}\u0026#34;,employeePageQueryDTO); 6 PageResult pageResult= employeeService.pagequery(employeePageQueryDTO); 7 return Result.success(pageResult); 8 } 定义PageResult,用来封装查询记录总数和分页查询结果,如下： 1@Data 2@AllArgsConstructor 3@NoArgsConstructor 4public class PageResult implements Serializable { 5 6 private long total; //总记录数 7 8 private List records; //当前页数据集合 9 10} Service层 1//Service层 2 public PageResult pagequery(EmployeePageQueryDTO employeePageQueryDTO) { 3 PageHelper.startPage(employeePageQueryDTO.getPage(),employeePageQueryDTO.getPageSize()); 4 Page\u0026lt;Employee\u0026gt; page =employeeMapper.pagequery(employeePageQueryDTO); 5 PageResult pageResult=new PageResult(); 6 pageResult.setRecords(page.getResult()); 7 pageResult.setTotal(page.getTotal()); 8 return pageResult; 9 } 在Service层用到PageHelper的核心用法： 开始分页：调用静态方法：\n1PageHelper.startPage(page,pageSize)； 其中，page为起始页码，pageSize为页面大小\n调用Mapper方法查询所需数据列表,类型为Page(或为所需类型)\n注：Page 属性（继承自 ArrayList） 属性名 类型 描述 pageNum int 当前页码 pageSize int 每页记录数 startRow int 当前页的起始行（包含） endRow int 当前页的结束行（包含） total long 总记录数 pages int 总页数 result List 当前页的数据列表（等同于本身） reasonable boolean 是否启用合理化分页 用getResult()方法获取页面结果，getTotal获取总记录数\n1//mapper层 2Page\u0026lt;Employee\u0026gt; pagequery(EmployeePageQueryDTO employeePageQueryDTO); 3 //employeeMapper.xml 4 \u0026lt;select id=\u0026#34;pagequery\u0026#34; resultType=\u0026#34;com.sky.entity.Employee\u0026#34;\u0026gt; 5 6 SELECT * FROM employee 7 \u0026lt;where\u0026gt; 8 \u0026lt;if test=\u0026#34;name != null and name != \u0026#39;\u0026#39;\u0026#34;\u0026gt; 9 AND name LIKE CONCAT(\u0026#39;%\u0026#39;, #{name}, \u0026#39;%\u0026#39;) 10 \u0026lt;/if\u0026gt; 11 \u0026lt;/where\u0026gt; 12 ORDER BY create_time DESC 13 14 \u0026lt;/select\u0026gt; ","date":"2025年8月2日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/blog/2025/08/pagehelper%E5%9C%A8springboot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","series":[],"smallImg":"","tags":[{"title":"Springboot","url":"/tags/springboot/"},{"title":"Mybatis","url":"/tags/mybatis/"},{"title":"Pagehelper","url":"/tags/pagehelper/"}],"timestamp":1754098269,"title":"Pagehelper在Springboot项目中的使用方法"},{"authors":[],"categories":[],"content":"这是一篇笔记\n","date":"2025年7月24日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/notes/git%E7%AC%94%E8%AE%B0.zh-cn/","series":[],"smallImg":"","tags":[],"timestamp":1753360442,"title":"Git笔记"},{"authors":[],"categories":[],"content":" Git 常用命令 1. 配置命令 1# 设置全局用户名和邮箱 2git config --global user.name \u0026#34;你的用户名\u0026#34; 3git config --global user.email \u0026#34;你的邮箱\u0026#34; 4 5# 查看配置信息 6git config --list 2. 初始化和基本操作 1# 初始化仓库 2git init 3 4# 克隆远程仓库 5git clone \u0026lt;repository-url\u0026gt; 6 7# 添加文件到暂存区 8git add \u0026lt;file-name\u0026gt; # 添加指定文件 9git add . # 添加所有文件 10 11# 提交更改 12git commit -m \u0026#34;提交说明\u0026#34; 13git commit -am \u0026#34;提交说明\u0026#34; # 合并 add 和 commit 3. 分支操作 1# 查看分支 2git branch # 查看本地分支 3git branch -r # 查看远程分支 4git branch -a # 查看所有分支 5 6# 创建分支 7git branch \u0026lt;branch-name\u0026gt; 8 9# 切换分支 10git checkout \u0026lt;branch-name\u0026gt; 11git switch \u0026lt;branch-name\u0026gt; # Git 2.23+ 新命令 12 13# 创建并切换分支 14git checkout -b \u0026lt;branch-name\u0026gt; 15git switch -c \u0026lt;branch-name\u0026gt; 16 17# 删除分支 18git branch -d \u0026lt;branch-name\u0026gt; # 删除本地分支 19git branch -D \u0026lt;branch-name\u0026gt; # 强制删除本地分支 20git push origin --delete \u0026lt;branch-name\u0026gt; # 删除远程分支 4. 远程仓库操作 1# 添加远程仓库 2git remote add origin \u0026lt;repository-url\u0026gt; 3 4# 查看远程仓库 5git remote -v 6 7# 推送到远程 8git push origin \u0026lt;branch-name\u0026gt; 9git push -u origin \u0026lt;branch-name\u0026gt; # 首次推送并设置上游分支 10 11# 拉取更新 12git pull origin \u0026lt;branch-name\u0026gt; 13git fetch origin # 获取远程更新但不合并 5. 状态和差异查看 1# 查看状态 2git status 3 4# 查看差异 5git diff # 工作区与暂存区的差异 6git diff --staged # 暂存区与最后一次提交的差异 7git diff \u0026lt;commit1\u0026gt; \u0026lt;commit2\u0026gt; # 两个提交之间的差异 6. 历史记录 1# 查看提交历史 2git log 3git log --oneline # 简洁模式 4git log --graph # 图形模式显示 5git reflog # 查看操作历史 7. 撤销和重置 1# 撤销工作区修改 2git checkout -- \u0026lt;file-name\u0026gt; 3git restore \u0026lt;file-name\u0026gt; # Git 2.23+ 新命令 4 5# 取消暂存 6git reset HEAD \u0026lt;file-name\u0026gt; 7git restore --staged \u0026lt;file-name\u0026gt; 8 9# 重置到指定提交 10git reset --soft \u0026lt;commit\u0026gt; # 保留工作区和暂存区修改 11git reset --mixed \u0026lt;commit\u0026gt; # 保留工作区修改（默认） 12git reset --hard \u0026lt;commit\u0026gt; # 清除所有修改 8. 暂存和合并 1# 暂存当前修改 2git stash 3git stash save \u0026#34;说明文字\u0026#34; 4 5# 查看暂存列表 6git stash list 7 8# 应用暂存 9git stash apply # 应用最近的暂存（不删除暂存记录） 10git stash pop # 应用最近的暂存（删除暂存记录） 11 12# 合并分支 13git merge \u0026lt;branch-name\u0026gt; 14git rebase \u0026lt;branch-name\u0026gt; # 变基 9. 标签管理 1# 创建标签 2git tag \u0026lt;tag-name\u0026gt; 3git tag -a \u0026lt;tag-name\u0026gt; -m \u0026#34;说明文字\u0026#34; 4 5# 查看标签 6git tag 7git show \u0026lt;tag-name\u0026gt; 8 9# 推送标签 10git push origin \u0026lt;tag-name\u0026gt; 11git push origin --tags # 推送所有标签 10. 高级技巧 1# 清理仓库 2git clean -f # 删除未跟踪文件 3git clean -fd # 删除未跟踪文件和目录 4 5# 修改最后一次提交 6git commit --amend 7 8# 查找内容 9git grep \u0026#34;查找的内容\u0026#34; 10 11# 锁定文件 12git update-index --assume-unchanged \u0026lt;file\u0026gt; 13git update-index --no-assume-unchanged \u0026lt;file\u0026gt; 最佳实践建议 经常性地提交代码，保持提交粒度适中 编写清晰的提交信息 定期从远程仓库拉取更新 使用分支进行功能开发 及时处理合并冲突 慎用 git reset --hard 命令 重要操作前先创建备份分支 常见问题解决 提交到错误分支：\n1git checkout correct-branch 2git cherry-pick wrong-branch 撤销已推送的提交：\n1git revert \u0026lt;commit\u0026gt; 修改提交信息：\n1git commit --amend 解决冲突：\n1git merge --abort # 取消合并 2git reset --merge # 重置合并 记住：使用 Git 最重要的是理解其工作流程和各个命令的作用，多加练习和实践才能熟练运用。\n","date":"2025年7月24日","img":"https://chongmingsuanjia521.github.io/images/ArticlesCover/git.png","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/posts/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/gitcommands.zh-cn/","series":[],"smallImg":"","tags":[],"timestamp":1753359677,"title":"Git常用命令"},{"authors":[],"categories":[{"title":"Git","url":"/categories/git/"}],"content":"Summary.\nContent.\n","date":"2025年7月24日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/blog/2025/07/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","series":[],"smallImg":"","tags":[{"title":"Git","url":"/tags/git/"},{"title":"命令","url":"/tags/%E5%91%BD%E4%BB%A4/"}],"timestamp":1753328592,"title":"Git常用命令"},{"authors":[],"categories":[],"content":"我是傻逼\n","date":"2025年7月23日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/about/","series":[],"smallImg":"","tags":[],"timestamp":1753228800,"title":"关于我"},{"authors":[],"categories":[{"title":"Installation","url":"/categories/installation/"}],"content":"This guide show you how to install on Arch Linux.\n","date":"2022年9月6日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/installation/linux/archlinux/","series":[{"title":"Guide","url":"/series/guide/"}],"smallImg":"","tags":[{"title":"Linux","url":"/tags/linux/"},{"title":"Arch Linux","url":"/tags/arch-linux/"}],"timestamp":1662475343,"title":"Install on Arch Linux"},{"authors":[],"categories":[],"content":"A fast, responsive and feature-rich Hugo theme for blog and documentations site.\n","date":"2022年9月6日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/introduction/","series":[{"title":"Guide","url":"/series/guide/"}],"smallImg":"","tags":[],"timestamp":1662475343,"title":"Introduction"},{"authors":[],"categories":[{"title":"Installation","url":"/categories/installation/"}],"content":"This guide show you how to install on Ubuntu.\n","date":"2022年9月6日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/installation/linux/ubuntu/","series":[{"title":"Guide","url":"/series/guide/"}],"smallImg":"","tags":[{"title":"Linux","url":"/tags/linux/"},{"title":"Ubuntu","url":"/tags/ubuntu/"}],"timestamp":1662475343,"title":"Install on Ubuntu"},{"authors":[],"categories":[{"title":"Installation","url":"/categories/installation/"}],"content":"This guide show you how to install on Windows.\n","date":"2022年9月6日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/docs/installation/windows/","series":[{"title":"Guide","url":"/series/guide/"}],"smallImg":"","tags":[{"title":"Windows","url":"/tags/windows/"}],"timestamp":1662475343,"title":"Install on Windows"},{"authors":[],"categories":[],"content":"See also README.md.\n","date":"2022年4月17日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/blog/2022/04/readme/","series":[],"smallImg":"","tags":[{"title":"README","url":"/tags/readme/"}],"timestamp":1650184529,"title":"README"},{"authors":[],"categories":[],"content":"","date":"1年1月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/authors/chongmingsuanjia/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"Chongmingsuanjia"},{"authors":[],"categories":[],"content":"","date":"1年1月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/offline/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"Offline"},{"authors":[],"categories":[],"content":"","date":"1年1月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/contact/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"联系我"}]
